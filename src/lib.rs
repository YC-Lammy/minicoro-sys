// Autogenerated binding to minicoro C library

#![allow(unused, non_camel_case_types, improper_ctypes)]

use core::ffi::c_char;

pub const MCO_DEFAULT_STORAGE_SIZE: usize = 1024;
pub const MCO_MIN_STACK_SIZE: usize = 32768;
pub const MCO_DEFAULT_STACK_SIZE: usize = 57344;

#[repr(C)]
pub struct mco_coro;

#[repr(C)]
#[derive(Debug, PartialEq, Eq)]
pub enum mco_result {
    MCO_SUCCESS = 0,
    MCO_GENERIC_ERROR,
    MCO_INVALID_POINTER,
    MCO_INVALID_COROUTINE,
    MCO_NOT_SUSPENDED,
    MCO_NOT_RUNNING,
    MCO_MAKE_CONTEXT_ERROR,
    MCO_SWITCH_CONTEXT_ERROR,
    MCO_NOT_ENOUGH_SPACE,
    MCO_OUT_OF_MEMORY,
    MCO_INVALID_ARGUMENTS,
    MCO_INVALID_OPERATION,
    MCO_STACK_OVERFLOW,
}

#[repr(C)]
#[derive(Debug, PartialEq, Eq)]
pub enum mco_state {
    MCO_DEAD = 0, /* The coroutine has finished normally or was uninitialized before finishing. */
    MCO_NORMAL, /* The coroutine is active but not running (that is, it has resumed another coroutine). */
    MCO_RUNNING, /* The coroutine is active and running. */
    MCO_SUSPENDED, /* The coroutine is suspended (in a call to yield, or it has not started running yet). */
}

#[repr(C)]
pub struct mco_desc {
    pub func: fn(co: *const mco_coro), /* Entry point function for the coroutine. */
    pub user_data: *const (),          /* Coroutine user data, can be get with `mco_get_user_data`. */
    /* Custom allocation interface. */
    pub malloc_cb: unsafe extern "C" fn(size: usize, allocator_data: *const ()) -> *const (), /* Custom allocation function. */
    pub free_cb: unsafe extern "C" fn(ptr: *const (), allocator_data: *const ()), /* Custom deallocation function. */
    pub allocator_data: *const (), /* User data pointer passed to `malloc`/`free` allocation functions. */
    pub storage_size: usize,       /* Coroutine storage size, to be used with the storage APIs. */
    /* These must be initialized only through `mco_init_desc`. */
    pub coro_size: usize,  /* Coroutine structure size. */
    pub stack_size: usize, /* Coroutine stack size. */
}

#[link(name = "minicoro", kind = "static")]
extern "C" {
    pub fn mco_desc_init(func: extern "C" fn(co: *const mco_coro), stack_size: usize) -> mco_desc; /* Initialize description of a coroutine. When stack size is 0 then MCO_DEFAULT_STACK_SIZE is used. */
    pub fn mco_init(co: *const mco_coro, desc: *const mco_desc) -> mco_result; /* Initialize the coroutine. */
    pub fn mco_uninit(co: *const mco_coro) -> mco_result; /* Uninitialize the coroutine, may fail if it's not dead or suspended. */
    pub fn mco_create(out_co: *mut *const mco_coro, desc: *const mco_desc) -> mco_result; /* Allocates and initializes a new coroutine. */
    pub fn mco_destroy(co: *const mco_coro) -> mco_result; /* Uninitialize and deallocate the coroutine, may fail if it's not dead or suspended. */
    pub fn mco_resume(co: *const mco_coro) -> mco_result; /* Starts or continues the execution of the coroutine. */
    pub fn mco_yield(co: *const mco_coro) -> mco_result; /* Suspends the execution of a coroutine. */
    pub fn mco_status(co: *const mco_coro) -> mco_state; /* Returns the status of the coroutine. */
    pub fn mco_get_user_data(co: *const mco_coro) -> *const u8; /* Get coroutine user data supplied on coroutine creation. */

    /* Storage interface functions, used to pass values between yield and resume. */
    pub fn mco_push(co: *const mco_coro, src: *const u8, len: usize) -> mco_result; /* Push bytes to the coroutine storage. Use to send values between yield and resume. */
    pub fn mco_pop(co: *const mco_coro, dest: *const u8, len: usize) -> mco_result; /* Pop bytes from the coroutine storage. Use to get values between yield and resume. */
    pub fn mco_peek(co: *const mco_coro, dest: *const u8, len: usize) -> mco_result; /* Like `mco_pop` but it does not consumes the storage. */
    pub fn mco_get_bytes_stored(co: *const mco_coro) -> usize; /* Get the available bytes that can be retrieved with a `mco_pop`. */
    pub fn mco_get_storage_size(co: *const mco_coro) -> usize; /* Get the total storage size. */

    /* Misc functions. */
    pub fn mco_running() -> *const mco_coro; /* Returns the running coroutine for the current thread. */
    pub fn mco_result_description(res: mco_result) -> *const c_char; /* Get the description of a result. */
}
